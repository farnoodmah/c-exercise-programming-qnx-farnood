shared_memory *shared_mem_ptr;
sem_t *mutex_sem, *buffer_count_sem,*spool_signal_sem;
int fd_shm, fd_log;
char mybuf [256];

mutex_sem = sem_open (SEM_MUTEX_NAME, O_CREAT, 0660, 0);
fd_shm = shm_open (SHARED_MEM_NAME, O_RDWR | O_CREAT | O_EXCL, 0660);
ftruncate (fd_shm, sizeof (struct shared_memory));
shared_mem_ptr = (struct shared_memory*) mmap (NULL, sizeof (struct shared_memory), PROT_READ | PROT_WRITE, MAP_SHARED,
            fd_shm, 0);

shared_mem_ptr -> buffer_index = shared_mem_ptr -> buffer_print_index = 0;
//counting semaphore, indicating the number of available buffers. Initial value = MAX_BUFFERS
buffer_count_sem = sem_open (SEM_BUFFER_COUNT_NAME, O_CREAT | O_EXCL, 0660, MAX_BUFFERS);
// counting semaphore, indicating the number of strings to be printed. Initial value = 0
spool_signal_sem = sem_open (SEM_SPOOL_SIGNAL_NAME, O_CREAT | O_EXCL, 0660, 0);

// Initialization complete; now we can set mutex semaphore as 1 to 
// indicate shared memory segment is available
sem_post (mutex_sem);

while (1) {  // forever
        // Is there a string to print? P (spool_signal_sem);
       sem_wait (spool_signal_sem);
    

        strcpy(mybuf,shared_mem_ptr->buf[shared_mem_ptr->buffer_print_index]);

        /* Since there is only one process (the logger) using the 
           buffer_print_index, mutex semaphore is not necessary */
        (shared_mem_ptr -> buffer_print_index)++;
        if (shared_mem_ptr -> buffer_print_index == MAX_BUFFERS)
           shared_mem_ptr -> buffer_print_index = 0;

        /* Contents of one buffer has been printed.
           One more buffer is available for use by producers.
           Release buffer: V (buffer_count_sem);  */
        if (sem_post (buffer_count_sem) == -1)
            error ("sem_post: buffer_count_sem");
        
        // write the string to file
        if (write (fd_log, mybuf, strlen (mybuf)) != strlen (mybuf))
            error ("write: logfile");
    }